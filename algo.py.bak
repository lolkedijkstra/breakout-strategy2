import logging
logger = logging.getLogger()

import statistics
from trading import Signal
from pivot import Pivot

ZONE_N_PIVOTS = 3

class algo:   
    
    @staticmethod
    def is_trend(close, open, ema, backcandles=10):    
        ema_signal = [0.0]*len(close)

        for idx in range(backcandles, len(close)):
            upt = 2 # 0x0010
            dnt = 1 # 0x0001
            
            r = range(idx-backcandles, idx+1)
            for i in r:
                if max(open[i], close[i]) > ema[i]:
                    dnt = 0
                    break
                
            for i in r:               
                if min(open[i], close[i]) < ema[i]:
                    upt = 0
                    break
                    
            ema_signal[idx] = upt | dnt
            
        return ema_signal
    

    @staticmethod
    def slice(data, b, e):
        return data.get(ago=e-data.buflen(), size=e-b)
      

    @staticmethod
    def get_pivot_hl(data, pivots, highlow, num=3):
        values = []
        for i in range(0, len(data)):
            if pivots[i] == highlow:
                values.append(data[i])
                
        return values[-num:]

    @staticmethod
    def get_pivot_high(data, pivots, num=3):
        return algo.get_pivot_hl(data, pivots, Pivot.HIGH, num)

    @staticmethod
    def get_pivot_low(data, pivots, num=3):
        return algo.get_pivot_hl(data, pivots, Pivot.LOW, num)
    
   

    #
    # data          
    # candle_idx    
    # backcandles   
    # gap_window    
    # pivots        
    # zone_width    
    # breakout_f    strength of breakout (min. = 1)
    #
    @staticmethod
    def calc_signal(data, candle_idx, backcandles, gap_window, pivots, zone_width, breakout_f): 
        # gap_window must be >= pivot window to avoid look ahead bias     
        begin = candle_idx - backcandles - gap_window
        end   = candle_idx - gap_window   
        
        if begin < 0 or candle_idx + gap_window >= data.buflen():
            return 0
        
        # check if pivots form a zone
        def is_zone(pivots, mean):
            for p in pivots:
                if abs(p - mean) > zone_width:
                    return False            
            return True
            
 
        # get last n pivot lows in window
        pvts  = algo.get_pivot_low(data=data.low.array[begin:end], pivots=pivots[begin:end], num=ZONE_N_PIVOTS)
                
        # if support is broken, it's a sell
        lb_low  = Signal.NONE
        if len(pvts) == ZONE_N_PIVOTS:
            mean_pvts = statistics.mean(pvts)
            current_close = data.close.array[candle_idx]
            
            if is_zone(pvts, mean_pvts) and (mean_pvts - current_close) > zone_width * breakout_f:
                lb_low = Signal.SELL
                logger.info(f'SELL SIGNAL: {candle_idx} strenght: {(current_close - mean_pvts)/zone_width}')

                
        # get last n pivot highs in window
        pvts = algo.get_pivot_high(data=data.high.array[begin:end], pivots=pivots[begin:end], num=ZONE_N_PIVOTS)
        
        # if resistance is broken, it's a buy
        lb_high = Signal.NONE
        if len(pvts) == ZONE_N_PIVOTS:
            mean_pvts = statistics.mean(pvts)
            current_close = data.close.array[candle_idx]
                
            if is_zone(pvts, mean_pvts) and (current_close - mean_pvts) > zone_width * breakout_f:
                lb_high = Signal.BUY
                logger.info(f'BUY SIGNAL: {candle_idx} strenght: {(current_close - mean_pvts)/zone_width}')
        
            
        # these should be exclusive, so result either NONE, BUY or SELL (never BUY|SELL)
        return lb_low | lb_high

